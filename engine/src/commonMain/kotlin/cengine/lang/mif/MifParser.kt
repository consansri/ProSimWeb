package cengine.lang.mif

import cengine.lang.mif.psi.MifAddressSpec
import cengine.lang.mif.psi.MifContentBlock
import cengine.lang.mif.psi.MifContentEntry
import cengine.lang.mif.psi.MifDirective
import cengine.lang.mif.psi.MifNumericValue
import cengine.lang.mif.psi.MifRadixValue
import cengine.psi.lexer.PsiTokenType
import cengine.psi.parser.PsiBuilder
import cengine.psi.parser.PsiTreeParser

/**
 * A PsiTreeParser implementation for the Memory Initialization File (MIF) language.
 * It parses a stream of tokens generated by a lexer (using MIFLexerSet)
 * into a PSI tree composed of MifElement nodes.
 */
object MifParser : PsiTreeParser {

    // MIF doesn't have complex expressions, so no Pratt parser config needed.

    /**
     * Main entry point for parsing a MIF file.
     */
    override fun PsiBuilder.parseFileContent() {
        // Mark the entire file
        io.debug { "Starting MIF file parse" }

        // Parse top-level elements: Directives and the Content Block
        while (!isAtEnd()) {
            skipWhitespaceAndComments(true) // Skip leading whitespace/comments before element
            if (isAtEnd()) break // Reached end after skipping

            if (!parseTopLevelElement()) {
                // If parseTopLevelElement returns false, it means an unexpected token
                // was found that couldn't start a known top-level element.
                // Report error and advance to avoid infinite loop.
                val token = peek()
                error("Unexpected token at top level: '${token?.value}' (${token?.type?.typeName})")
                advance() // Consume the unexpected token
            }
        }

        // Complete the marker for the MifFile node
        io.debug { "Finished MIF file parse" }
    }

    /**
     * Parses a single top-level element, which can be a directive or the content block.
     * Returns true if a known element was successfully parsed (or an error within it handled),
     * false if the current token cannot start a known top-level element.
     */
    private fun PsiBuilder.parseTopLevelElement(): Boolean {
        val tokenType = getTokenType()
        val tokenValue = getTokenText()?.uppercase() // Use uppercase for keyword matching

        return when {
            // Check for Directive Keywords
            tokenType == PsiTokenType.KEYWORD && tokenValue in setOf("WIDTH", "DEPTH", "ADDRESS_RADIX", "DATA_RADIX") -> {
                parseDirective() != null // parseDirective handles its own marker and errors
            }
            // Check for Content Block Start
            tokenType == PsiTokenType.KEYWORD && tokenValue == "CONTENT" -> {
                parseContentBlock() != null // parseContentBlock handles its own marker and errors
            }
            // Cannot start a known top-level element
            else -> false
        }
    }

    // --- Directive Parsing ---

    /**
     * Parses any MIF directive (WIDTH, DEPTH, ADDRESS_RADIX, DATA_RADIX).
     * Assumes the current token is one of the directive keywords.
     * Returns the completed marker for the directive node or null on failure.
     */
    private fun PsiBuilder.parseDirective(): PsiBuilder.Marker? {
        val keyword = peek()?.value?.uppercase()
        io.debug { "Attempting to parse directive starting with '$keyword'" }

        // Determine specific directive type and parse accordingly
        return when (keyword) {
            "WIDTH" -> parseWidthDirective()
            "DEPTH" -> parseDepthDirective()
            "ADDRESS_RADIX" -> parseAddressRadixDirective()
            "DATA_RADIX" -> parseDataRadixDirective()
            else -> {
                // Should not happen if called correctly
                error("Internal Error: parseDirective called with unexpected keyword '$keyword'")
                null
            }
        }
    }

    private fun PsiBuilder.parseWidthDirective(): PsiBuilder.Marker? {
        val marker = mark()
        if (!expect(PsiTokenType.KEYWORD)) {
            marker.drop(); return null
        } // Consume WIDTH

        skipWhitespaceAndComments(true)

        if (!expect("=")) {
            marker.drop(); return null
        }

        skipWhitespaceAndComments(true)

        if (parseNumericValue() == null) { // Numeric value is required
            error("Expected numeric value for WIDTH directive")
            marker.drop(); return null
        }

        skipWhitespaceAndComments(true)

        if (!expect(";")) {
            marker.drop(); return null
        }

        marker.done(MifDirective.Width)
        io.debug { "Parsed WIDTH directive" }
        return marker
    }

    private fun PsiBuilder.parseDepthDirective(): PsiBuilder.Marker? {
        val marker = mark()
        if (!expect(PsiTokenType.KEYWORD)) {
            marker.drop(); return null
        } // Consume DEPTH

        skipWhitespaceAndComments(true)

        if (!expect("=")) {
            marker.drop(); return null
        }

        skipWhitespaceAndComments(true)

        if (parseNumericValue() == null) {
            error("Expected numeric value for DEPTH directive")
            marker.drop(); return null
        }

        skipWhitespaceAndComments(true)

        if (!expect(";")) {
            marker.drop(); return null
        }
        marker.done(MifDirective.Depth)
        io.debug { "Parsed DEPTH directive" }
        return marker
    }

    private fun PsiBuilder.parseAddressRadixDirective(): PsiBuilder.Marker? {
        val marker = mark()
        if (!expect(PsiTokenType.KEYWORD)) {
            marker.drop(); return null
        } // Consume ADDRESS_RADIX

        skipWhitespaceAndComments(true)

        if (!expect("=")) {
            marker.drop(); return null
        }

        skipWhitespaceAndComments(true)

        if (parseRadixValue() == null) { // Radix value is required
            error("Expected radix value (HEX, BIN, DEC, OCT, UNS) for ADDRESS_RADIX directive")
            marker.drop(); return null
        }

        skipWhitespaceAndComments(true)

        if (!expect(";")) {
            marker.drop(); return null
        }
        marker.done(MifDirective.AddressRadix)
        io.debug { "Parsed ADDRESS_RADIX directive" }
        return marker
    }

    private fun PsiBuilder.parseDataRadixDirective(): PsiBuilder.Marker? {
        val marker = mark()
        if (!expect(PsiTokenType.KEYWORD)) {
            marker.drop(); return null
        } // Consume DATA_RADIX

        skipWhitespaceAndComments(true)

        if (!expect("=")) {
            marker.drop(); return null
        }

        skipWhitespaceAndComments(true)

        if (parseRadixValue() == null) {
            error("Expected radix value (HEX, BIN, DEC, OCT, UNS) for DATA_RADIX directive")
            marker.drop(); return null
        }

        skipWhitespaceAndComments(true)

        if (!expect(";")) {
            marker.drop(); return null
        }
        marker.done(MifDirective.DataRadix)
        io.debug { "Parsed DATA_RADIX directive" }
        return marker
    }

    // --- Value Parsing Helpers ---

    /** Parses a token that represents a numeric value (Identifier or Integer Literal). */
    private fun PsiBuilder.parseNumericValue(): PsiBuilder.Marker? {
        skipWhitespaceAndComments(true)
        val tokenType = getTokenType()
        if (tokenType == PsiTokenType.IDENTIFIER) {
            val marker = mark()
            advance() // Consume the token
            marker.done(MifNumericValue)
            return marker
        }
        return null // Not a valid numeric value token
    }

    /** Parses a token that represents a radix keyword (HEX, BIN, etc.). */
    private fun PsiBuilder.parseRadixValue(): PsiBuilder.Marker? {
        skipWhitespaceAndComments(true)
        val tokenType = getTokenType()
        val tokenValue = getTokenText()?.uppercase()
        if (tokenType == PsiTokenType.KEYWORD && tokenValue in setOf("HEX", "BIN", "OCT", "DEC", "UNS")) {
            val marker = mark()
            advance() // Consume the keyword
            marker.done(MifRadixValue)
            return marker
        }
        return null // Not a valid radix keyword
    }


    // --- Content Block Parsing ---

    /**
     * Parses the CONTENT BEGIN ... END; block.
     * Assumes the current token is the CONTENT keyword.
     * Returns the completed marker for the block or null on failure.
     */
    private fun PsiBuilder.parseContentBlock(): PsiBuilder.Marker? {
        io.debug { "Attempting to parse CONTENT block" }
        val blockMarker = mark()

        // Expect CONTENT BEGIN
        if (!expect("CONTENT", ignoreCase = true)) {
            blockMarker.drop(); return null
        }
        skipWhitespaceAndComments(true)
        if (!expect("BEGIN", ignoreCase = true)) {
            blockMarker.drop(); return null
        }

        // Parse content entries until END
        while (!isAtEnd() && !currentIs("END", ignoreCase = true)) {
            skipWhitespaceAndComments(true)
            if (currentIs(PsiTokenType.KEYWORD) && peek()?.value.equals("END", ignoreCase = true)) {
                break // Found END before parsing next entry
            }
            if (isAtEnd()) {
                error("Unexpected end of file within CONTENT block, expected END keyword")
                blockMarker.done(MifContentBlock); return blockMarker // Complete marker with error implicitly
            }

            if (parseContentEntry() == null) {
                // If parseContentEntry returns null, it failed to parse an entry.
                // Report error and consume token to avoid loop.
                val token = peek()
                error("Expected content entry or END keyword, found '${token?.value}'")
                advance() // Consume the unexpected token
            }
        }

        // Expect END ;
        expect("END", ignoreCase = true)
        skipWhitespaceAndComments(true)
        expect(";")

        blockMarker.done(MifContentBlock)
        io.debug { "Parsed CONTENT block" }
        return blockMarker
    }

    /**
     * Parses a single content entry: AddressSpec : Value(s) ;
     * Returns the completed marker or null if parsing failed or END is reached.
     */
    private fun PsiBuilder.parseContentEntry(): PsiBuilder.Marker? {
        skipWhitespaceAndComments(true)
        // Check if we are at the END keyword - signifies end of entries
        if (currentIs("END", ignoreCase = true)) {
            return null
        }
        // Also handle EOF case within content block
        if (isAtEnd()) {
            return null
        }

        io.debug { "Attempting to parse content entry starting at '${peek()?.value}'" }
        val entryMarker = mark()

        // 1. Parse Address Specification
        if (parseAddressSpec() == null) {
            error("Expected address specification (single, range, or list)")
            entryMarker.drop(); return null
        }

        skipWhitespaceAndComments(true)

        // 2. Expect Colon
        if (!expect(":")) {
            entryMarker.drop(); return null
        }

        // 3. Parse Data Value(s) - At least one required
        var valuesParsed = 0
        while (!isAtEnd() && !currentIs(";")) {
            skipWhitespaceAndComments(true)
            if (currentIs(";")) break // Reached terminator

            if (parseNumericValue() != null) {
                valuesParsed++
            } else {
                // Found something other than a value or semicolon
                error("Expected data value or ';', found '${peek()?.value}'")
                // Consume the unexpected token to prevent infinite loop and attempt recovery
                advance()
                // Optionally break here, or continue trying to parse values after the error
                // For robustness, let's break and expect the semicolon next
                break
            }
        }

        if (valuesParsed == 0) {
            error("Missing data value(s) after ':'")
            // No need to rollback marker, complete it as an error node
            // We still need to consume the expected semicolon if present
            if (currentIs(";")) expect(";") else error("Missing semicolon after data value error")
            entryMarker.done(MifContentEntry); return entryMarker
        }

        // 4. Expect Semicolon
        if (!expect(";")) {
            // Error reported by expect, but complete the marker anyway
            entryMarker.done(MifContentEntry); return entryMarker
        }

        entryMarker.done(MifContentEntry)
        io.debug { "Parsed content entry" }
        return entryMarker
    }

    // --- Address Specification Parsing ---

    /** Parses any valid address specification (single, range, or list). */
    private fun PsiBuilder.parseAddressSpec(): PsiBuilder.Marker? {
        skipWhitespaceAndComments(true)
        return when {
            // Starts with '[' -> Range or List
            currentIs("[") -> parseBracketedAddressSpec()
            // Starts with potential numeric value -> Single Address
            getTokenType() == PsiTokenType.IDENTIFIER -> parseAddressSingle()
            // Cannot start an address specification
            else -> null
        }
    }

    private fun PsiBuilder.parseAddressSingle(): PsiBuilder.Marker? {
        io.debug { "Attempting to parse address single" }
        val specMarker = mark()
        if (!expect(PsiTokenType.IDENTIFIER)) {
            specMarker.drop(); return null
        }
        specMarker.done(MifAddressSpec.Single)
        io.debug { "Parsed address single" }
        return specMarker
    }

    /** Parses address specs starting with '[' (Range or List). */
    private fun PsiBuilder.parseBracketedAddressSpec(): PsiBuilder.Marker? {
        io.debug { "Attempting to parse bracketed address spec" }
        val bracketMarker = mark()
        if (!expect("[")) {
            bracketMarker.drop(); return null
        }

        // Parse the first numeric value (required for both list and range)
        if (parseAddressSingle() == null) {
            error("Expected address value after '['")
            bracketMarker.drop(); return null
        }

        skipWhitespaceAndComments(true)
        when {
            // Check for Range ".."
            currentIs("..") -> {
                advance() // Consume ".."
                if (parseAddressSingle() == null) { // Expect end value
                    error("Expected end address value after '..'")
                    bracketMarker.drop(); return null
                }
                if (!expect("]")) {
                    bracketMarker.drop(); return null
                }
                bracketMarker.done(MifAddressSpec.Range)
                io.debug { "Parsed range address spec" }
                return bracketMarker
            }
            // Check for List "," or immediate "]"
            currentIs(",") || currentIs("]") -> {
                // It's a list, potentially with more items
                while (currentIs(",")) {
                    advance() // Consume ","
                    if (parseAddressSingle() == null) { // Expect value after comma
                        error("Expected address value after ','")
                        // Allow recovery - maybe the ']' is next?
                        // Let's break and expect ']'
                        break
                    }
                    skipWhitespaceAndComments(true)
                }
                // Expect the closing bracket
                if (!expect("]")) {
                    bracketMarker.drop(); return null
                }
                bracketMarker.done(MifAddressSpec.RangeList)
                io.debug { "Parsed list address spec" }
                return bracketMarker
            }
            // Unexpected token after first value inside brackets
            else -> {
                error("Expected '..', ',', or ']' after first address value in brackets, found '${peek()?.value}'")
                bracketMarker.drop(); return null
            }
        }
    }
}