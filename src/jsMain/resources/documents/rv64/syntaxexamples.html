<h1>Syntax Examples</h1>
<h2>Sections</h2>
<pre><code>.data
# allocate read/write initialized memory
    dataEx:         .string "hello world"           # behaves as byte array (dependent on endianess)
    labeledArray:   .byte   0xCA, 0xFE, 0xAF, 0xFE  # classic byte array (dependent on endianess)

    .word   -4134
    .dword  0xCAFEAFFEDEADBEEF
    # ...

.rodata
# allocate read only initialized memory
    rodataEx: .string "read only"

.bss
# allocate read/write uninitialized memory
    bssEx: .string

.text
# define instructions and jumplabels

    la	t0, dataEx 	# loads address of allocated memory in register t0
</code></pre>
<h2>Macros</h2>
<pre><code>.macro push reg
    addi sp, sp, -4
    sw \reg, 0(sp)
.endm

.macro pop reg
    lw \reg, 0(sp)
    addi sp, sp, 4
.endm

    li	sp, 0xFFFFFFFC	#stack pointer initialization
prog:
    # some program which calls a function
    push	ra
    call .foo1
    pop	ra
    call	.end

.foo1:
    # a function which calls another function
    push	ra
    call .foo2
    pop	ra
    ret

.foo2:
    # another function
    ret

.end:
</code></pre>
<h2>Constants</h2>
<pre><code>.equ SP_INIT, 0xFFFFFFFC

li	sp, SP_INIT
</code></pre>
<h2>Start of Program</h2>
<pre><code>.globl person # defines the program start
# instead of .globl you can also use .global

eat:
	# eat
	ret

sleep:
	# sleep
	ret

person:
	# program starts here
	li	t1, 10

.lives:
	jal	eat
	jal	sleep
	addi	t0, t0, 1
	beq	t0, t1, .die
	j	.lives

.die:
	# program ends here
</code></pre>
<h2>File Imports</h2>
<pre><code>#import "person.s"
#imports the whole person syntax, use it through labels

main:
	# example usage "person:" label is defined in "person.s"
	jal	person
</code></pre>